// @flow
// generated by scripts/generate-babel-types.js


let t: any = null;
let currentLocation: any = null;
export function getCurrentLocation(): Location { return currentLocation; }
export function setCurrentLocation(loc: Location): Location { return currentLocation = loc; }
export function setBabelTypes(_t: Object): Location { return t = _t; }

const BabelTypes = {
  anyTypeAnnotation(): AnyTypeAnnotation {
    const args = ([].slice: any).call(arguments);
    const loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.AnyTypeAnnotation(...args), loc: hasLoc ? (loc: any) : getCurrentLocation()};
  },
  arrayExpression(elements: ?$ReadOnlyArray<null | Expression | SpreadElement>): ArrayExpression {
    const args = ([].slice: any).call(arguments);
    const loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.ArrayExpression(...args), loc: hasLoc ? (loc: any) : getCurrentLocation()};
  },
  arrayPattern(elements: $ReadOnlyArray<Expression>, typeAnnotation: mixed): ArrayPattern {
    const args = ([].slice: any).call(arguments);
    const loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.ArrayPattern(...args), loc: hasLoc ? (loc: any) : getCurrentLocation()};
  },
  arrayTypeAnnotation(elementType: mixed): ArrayTypeAnnotation {
    const args = ([].slice: any).call(arguments);
    const loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.ArrayTypeAnnotation(...args), loc: hasLoc ? (loc: any) : getCurrentLocation()};
  },
  arrowFunctionExpression(params: $ReadOnlyArray<LVal>, body: BlockStatement | Expression, async: ?boolean): ArrowFunctionExpression {
    const args = ([].slice: any).call(arguments);
    const loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.ArrowFunctionExpression(...args), loc: hasLoc ? (loc: any) : getCurrentLocation()};
  },
  assignmentExpression(operator: string, left: LVal, right: Expression): AssignmentExpression {
    const args = ([].slice: any).call(arguments);
    const loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.AssignmentExpression(...args), loc: hasLoc ? (loc: any) : getCurrentLocation()};
  },
  assignmentPattern(left: Identifier, right: Expression): AssignmentPattern {
    const args = ([].slice: any).call(arguments);
    const loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.AssignmentPattern(...args), loc: hasLoc ? (loc: any) : getCurrentLocation()};
  },
  awaitExpression(argument: Expression): AwaitExpression {
    const args = ([].slice: any).call(arguments);
    const loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.AwaitExpression(...args), loc: hasLoc ? (loc: any) : getCurrentLocation()};
  },
  binaryExpression(operator: '+' | '-' | '/' | '%' | '*' | '**' | '&' | '|' | '>>' | '>>>' | '<<' | '^' | '==' | '===' | '!=' | '!==' | 'in' | 'instanceof' | '>' | '<' | '>=' | '<=', left: Expression, right: Expression): BinaryExpression {
    const args = ([].slice: any).call(arguments);
    const loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.BinaryExpression(...args), loc: hasLoc ? (loc: any) : getCurrentLocation()};
  },
  bindExpression(object: mixed, callee: mixed): BindExpression {
    const args = ([].slice: any).call(arguments);
    const loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.BindExpression(...args), loc: hasLoc ? (loc: any) : getCurrentLocation()};
  },
  blockStatement(body: $ReadOnlyArray<Statement>, directives: ?$ReadOnlyArray<Directive>): BlockStatement {
    const args = ([].slice: any).call(arguments);
    const loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.BlockStatement(...args), loc: hasLoc ? (loc: any) : getCurrentLocation()};
  },
  booleanLiteral(value: boolean): BooleanLiteral {
    const args = ([].slice: any).call(arguments);
    const loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.BooleanLiteral(...args), loc: hasLoc ? (loc: any) : getCurrentLocation()};
  },
  booleanLiteralTypeAnnotation(): BooleanLiteralTypeAnnotation {
    const args = ([].slice: any).call(arguments);
    const loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.BooleanLiteralTypeAnnotation(...args), loc: hasLoc ? (loc: any) : getCurrentLocation()};
  },
  booleanTypeAnnotation(): BooleanTypeAnnotation {
    const args = ([].slice: any).call(arguments);
    const loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.BooleanTypeAnnotation(...args), loc: hasLoc ? (loc: any) : getCurrentLocation()};
  },
  breakStatement(label: ?Identifier): BreakStatement {
    const args = ([].slice: any).call(arguments);
    const loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.BreakStatement(...args), loc: hasLoc ? (loc: any) : getCurrentLocation()};
  },
  callExpression(callee: Expression, _arguments: $ReadOnlyArray<Expression | SpreadElement>): CallExpression {
    const args = ([].slice: any).call(arguments);
    const loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.CallExpression(...args), loc: hasLoc ? (loc: any) : getCurrentLocation()};
  },
  catchClause(param: Identifier, body: BlockStatement): CatchClause {
    const args = ([].slice: any).call(arguments);
    const loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.CatchClause(...args), loc: hasLoc ? (loc: any) : getCurrentLocation()};
  },
  classBody(body: $ReadOnlyArray<ClassMethod | ClassProperty>): ClassBody {
    const args = ([].slice: any).call(arguments);
    const loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.ClassBody(...args), loc: hasLoc ? (loc: any) : getCurrentLocation()};
  },
  classDeclaration(id: Identifier, superClass: ?Expression, body: ClassBody, decorators: $ReadOnlyArray<Decorator>): ClassDeclaration {
    const args = ([].slice: any).call(arguments);
    const loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.ClassDeclaration(...args), loc: hasLoc ? (loc: any) : getCurrentLocation()};
  },
  classExpression(id: ?Identifier, superClass: ?Expression, body: ClassBody, decorators: $ReadOnlyArray<Decorator>): ClassExpression {
    const args = ([].slice: any).call(arguments);
    const loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.ClassExpression(...args), loc: hasLoc ? (loc: any) : getCurrentLocation()};
  },
  classImplements(id: mixed, typeParameters: mixed): ClassImplements {
    const args = ([].slice: any).call(arguments);
    const loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.ClassImplements(...args), loc: hasLoc ? (loc: any) : getCurrentLocation()};
  },
  classMethod(kind: ?"get" | "set" | "method" | "constructor", key: Expression, params: $ReadOnlyArray<LVal>, body: BlockStatement, computed: ?boolean, _static: ?boolean): ClassMethod {
    const args = ([].slice: any).call(arguments);
    const loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.ClassMethod(...args), loc: hasLoc ? (loc: any) : getCurrentLocation()};
  },
  classProperty(key: mixed, value: mixed, typeAnnotation: mixed, decorators: mixed, computed: ?boolean): ClassProperty {
    const args = ([].slice: any).call(arguments);
    const loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.ClassProperty(...args), loc: hasLoc ? (loc: any) : getCurrentLocation()};
  },
  conditionalExpression(test: Expression, consequent: Expression, alternate: Expression): ConditionalExpression {
    const args = ([].slice: any).call(arguments);
    const loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.ConditionalExpression(...args), loc: hasLoc ? (loc: any) : getCurrentLocation()};
  },
  continueStatement(label: ?Identifier): ContinueStatement {
    const args = ([].slice: any).call(arguments);
    const loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.ContinueStatement(...args), loc: hasLoc ? (loc: any) : getCurrentLocation()};
  },
  debuggerStatement(): DebuggerStatement {
    const args = ([].slice: any).call(arguments);
    const loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.DebuggerStatement(...args), loc: hasLoc ? (loc: any) : getCurrentLocation()};
  },
  declareClass(id: mixed, typeParameters: mixed, _extends: mixed, body: mixed): DeclareClass {
    const args = ([].slice: any).call(arguments);
    const loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.DeclareClass(...args), loc: hasLoc ? (loc: any) : getCurrentLocation()};
  },
  declareFunction(id: mixed): DeclareFunction {
    const args = ([].slice: any).call(arguments);
    const loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.DeclareFunction(...args), loc: hasLoc ? (loc: any) : getCurrentLocation()};
  },
  declareInterface(id: mixed, typeParameters: mixed, _extends: mixed, body: mixed): DeclareInterface {
    const args = ([].slice: any).call(arguments);
    const loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.DeclareInterface(...args), loc: hasLoc ? (loc: any) : getCurrentLocation()};
  },
  declareModule(id: mixed, body: mixed): DeclareModule {
    const args = ([].slice: any).call(arguments);
    const loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.DeclareModule(...args), loc: hasLoc ? (loc: any) : getCurrentLocation()};
  },
  declareModuleExports(typeAnnotation: mixed): DeclareModuleExports {
    const args = ([].slice: any).call(arguments);
    const loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.DeclareModuleExports(...args), loc: hasLoc ? (loc: any) : getCurrentLocation()};
  },
  declareTypeAlias(id: mixed, typeParameters: mixed, right: mixed): DeclareTypeAlias {
    const args = ([].slice: any).call(arguments);
    const loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.DeclareTypeAlias(...args), loc: hasLoc ? (loc: any) : getCurrentLocation()};
  },
  declareVariable(id: mixed): DeclareVariable {
    const args = ([].slice: any).call(arguments);
    const loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.DeclareVariable(...args), loc: hasLoc ? (loc: any) : getCurrentLocation()};
  },
  decorator(expression: Expression): Decorator {
    const args = ([].slice: any).call(arguments);
    const loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.Decorator(...args), loc: hasLoc ? (loc: any) : getCurrentLocation()};
  },
  directive(value: DirectiveLiteral): Directive {
    const args = ([].slice: any).call(arguments);
    const loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.Directive(...args), loc: hasLoc ? (loc: any) : getCurrentLocation()};
  },
  directiveLiteral(value: string): DirectiveLiteral {
    const args = ([].slice: any).call(arguments);
    const loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.DirectiveLiteral(...args), loc: hasLoc ? (loc: any) : getCurrentLocation()};
  },
  doExpression(body: BlockStatement): DoExpression {
    const args = ([].slice: any).call(arguments);
    const loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.DoExpression(...args), loc: hasLoc ? (loc: any) : getCurrentLocation()};
  },
  doWhileStatement(test: Expression, body: Statement): DoWhileStatement {
    const args = ([].slice: any).call(arguments);
    const loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.DoWhileStatement(...args), loc: hasLoc ? (loc: any) : getCurrentLocation()};
  },
  emptyStatement(): EmptyStatement {
    const args = ([].slice: any).call(arguments);
    const loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.EmptyStatement(...args), loc: hasLoc ? (loc: any) : getCurrentLocation()};
  },
  emptyTypeAnnotation(): EmptyTypeAnnotation {
    const args = ([].slice: any).call(arguments);
    const loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.EmptyTypeAnnotation(...args), loc: hasLoc ? (loc: any) : getCurrentLocation()};
  },
  existentialTypeParam(): ExistentialTypeParam {
    const args = ([].slice: any).call(arguments);
    const loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.ExistentialTypeParam(...args), loc: hasLoc ? (loc: any) : getCurrentLocation()};
  },
  exportAllDeclaration(source: StringLiteral): ExportAllDeclaration {
    const args = ([].slice: any).call(arguments);
    const loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.ExportAllDeclaration(...args), loc: hasLoc ? (loc: any) : getCurrentLocation()};
  },
  exportDefaultDeclaration(declaration: FunctionDeclaration | ClassDeclaration | Expression): ExportDefaultDeclaration {
    const args = ([].slice: any).call(arguments);
    const loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.ExportDefaultDeclaration(...args), loc: hasLoc ? (loc: any) : getCurrentLocation()};
  },
  exportDefaultSpecifier(exported: Identifier): ExportDefaultSpecifier {
    const args = ([].slice: any).call(arguments);
    const loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.ExportDefaultSpecifier(...args), loc: hasLoc ? (loc: any) : getCurrentLocation()};
  },
  exportNamedDeclaration(declaration: ?Declaration, specifiers: $ReadOnlyArray<ExportSpecifier>, source: ?StringLiteral): ExportNamedDeclaration {
    const args = ([].slice: any).call(arguments);
    const loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.ExportNamedDeclaration(...args), loc: hasLoc ? (loc: any) : getCurrentLocation()};
  },
  exportNamespaceSpecifier(exported: Identifier): ExportNamespaceSpecifier {
    const args = ([].slice: any).call(arguments);
    const loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.ExportNamespaceSpecifier(...args), loc: hasLoc ? (loc: any) : getCurrentLocation()};
  },
  exportSpecifier(local: Identifier, exported: Identifier): ExportSpecifier {
    const args = ([].slice: any).call(arguments);
    const loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.ExportSpecifier(...args), loc: hasLoc ? (loc: any) : getCurrentLocation()};
  },
  expressionStatement(expression: Expression): ExpressionStatement {
    const args = ([].slice: any).call(arguments);
    const loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.ExpressionStatement(...args), loc: hasLoc ? (loc: any) : getCurrentLocation()};
  },
  file(program: Program, comments: mixed, tokens: mixed): File {
    const args = ([].slice: any).call(arguments);
    const loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.File(...args), loc: hasLoc ? (loc: any) : getCurrentLocation()};
  },
  forAwaitStatement(left: VariableDeclaration | LVal, right: Expression, body: Statement): ForAwaitStatement {
    const args = ([].slice: any).call(arguments);
    const loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.ForAwaitStatement(...args), loc: hasLoc ? (loc: any) : getCurrentLocation()};
  },
  forInStatement(left: VariableDeclaration | LVal, right: Expression, body: Statement): ForInStatement {
    const args = ([].slice: any).call(arguments);
    const loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.ForInStatement(...args), loc: hasLoc ? (loc: any) : getCurrentLocation()};
  },
  forOfStatement(left: VariableDeclaration | LVal, right: Expression, body: Statement): ForOfStatement {
    const args = ([].slice: any).call(arguments);
    const loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.ForOfStatement(...args), loc: hasLoc ? (loc: any) : getCurrentLocation()};
  },
  forStatement(init: ?VariableDeclaration | Expression, test: ?Expression, update: ?Expression, body: Statement): ForStatement {
    const args = ([].slice: any).call(arguments);
    const loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.ForStatement(...args), loc: hasLoc ? (loc: any) : getCurrentLocation()};
  },
  functionDeclaration(id: Identifier, params: $ReadOnlyArray<LVal>, body: BlockStatement, generator: ?boolean, async: ?boolean): FunctionDeclaration {
    const args = ([].slice: any).call(arguments);
    const loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.FunctionDeclaration(...args), loc: hasLoc ? (loc: any) : getCurrentLocation()};
  },
  functionExpression(id: ?Identifier, params: $ReadOnlyArray<LVal>, body: BlockStatement, generator: ?boolean, async: ?boolean): FunctionExpression {
    const args = ([].slice: any).call(arguments);
    const loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.FunctionExpression(...args), loc: hasLoc ? (loc: any) : getCurrentLocation()};
  },
  functionTypeAnnotation(typeParameters: mixed, params: mixed, rest: mixed, returnType: mixed): FunctionTypeAnnotation {
    const args = ([].slice: any).call(arguments);
    const loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.FunctionTypeAnnotation(...args), loc: hasLoc ? (loc: any) : getCurrentLocation()};
  },
  functionTypeParam(name: mixed, typeAnnotation: mixed): FunctionTypeParam {
    const args = ([].slice: any).call(arguments);
    const loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.FunctionTypeParam(...args), loc: hasLoc ? (loc: any) : getCurrentLocation()};
  },
  genericTypeAnnotation(id: mixed, typeParameters: mixed): GenericTypeAnnotation {
    const args = ([].slice: any).call(arguments);
    const loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.GenericTypeAnnotation(...args), loc: hasLoc ? (loc: any) : getCurrentLocation()};
  },
  identifier(name: string): Identifier {
    const args = ([].slice: any).call(arguments);
    const loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.Identifier(...args), loc: hasLoc ? (loc: any) : getCurrentLocation()};
  },
  ifStatement(test: Expression, consequent: Statement, alternate: ?Statement): IfStatement {
    const args = ([].slice: any).call(arguments);
    const loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.IfStatement(...args), loc: hasLoc ? (loc: any) : getCurrentLocation()};
  },
  import(): Import {
    const args = ([].slice: any).call(arguments);
    const loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.Import(...args), loc: hasLoc ? (loc: any) : getCurrentLocation()};
  },
  importDeclaration(specifiers: $ReadOnlyArray<ImportSpecifier | ImportDefaultSpecifier | ImportNamespaceSpecifier>, source: StringLiteral): ImportDeclaration {
    const args = ([].slice: any).call(arguments);
    const loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.ImportDeclaration(...args), loc: hasLoc ? (loc: any) : getCurrentLocation()};
  },
  importDefaultSpecifier(local: Identifier): ImportDefaultSpecifier {
    const args = ([].slice: any).call(arguments);
    const loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.ImportDefaultSpecifier(...args), loc: hasLoc ? (loc: any) : getCurrentLocation()};
  },
  importNamespaceSpecifier(local: Identifier): ImportNamespaceSpecifier {
    const args = ([].slice: any).call(arguments);
    const loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.ImportNamespaceSpecifier(...args), loc: hasLoc ? (loc: any) : getCurrentLocation()};
  },
  importSpecifier(local: Identifier, imported: Identifier): ImportSpecifier {
    const args = ([].slice: any).call(arguments);
    const loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.ImportSpecifier(...args), loc: hasLoc ? (loc: any) : getCurrentLocation()};
  },
  interfaceDeclaration(id: mixed, typeParameters: mixed, _extends: mixed, body: mixed): InterfaceDeclaration {
    const args = ([].slice: any).call(arguments);
    const loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.InterfaceDeclaration(...args), loc: hasLoc ? (loc: any) : getCurrentLocation()};
  },
  interfaceExtends(id: mixed, typeParameters: mixed): InterfaceExtends {
    const args = ([].slice: any).call(arguments);
    const loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.InterfaceExtends(...args), loc: hasLoc ? (loc: any) : getCurrentLocation()};
  },
  intersectionTypeAnnotation(types: mixed): IntersectionTypeAnnotation {
    const args = ([].slice: any).call(arguments);
    const loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.IntersectionTypeAnnotation(...args), loc: hasLoc ? (loc: any) : getCurrentLocation()};
  },
  jSXAttribute(name: JSXIdentifier | JSXNamespacedName, value: ?JSXElement | StringLiteral | JSXExpressionContainer): JSXAttribute {
    const args = ([].slice: any).call(arguments);
    const loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.JSXAttribute(...args), loc: hasLoc ? (loc: any) : getCurrentLocation()};
  },
  jSXClosingElement(name: JSXIdentifier | JSXMemberExpression): JSXClosingElement {
    const args = ([].slice: any).call(arguments);
    const loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.JSXClosingElement(...args), loc: hasLoc ? (loc: any) : getCurrentLocation()};
  },
  jSXElement(openingElement: JSXOpeningElement, closingElement: ?JSXClosingElement, children: $ReadOnlyArray<JSXText | JSXExpressionContainer | JSXSpreadChild | JSXElement>, selfClosing: mixed): JSXElement {
    const args = ([].slice: any).call(arguments);
    const loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.JSXElement(...args), loc: hasLoc ? (loc: any) : getCurrentLocation()};
  },
  jSXEmptyExpression(): JSXEmptyExpression {
    const args = ([].slice: any).call(arguments);
    const loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.JSXEmptyExpression(...args), loc: hasLoc ? (loc: any) : getCurrentLocation()};
  },
  jSXExpressionContainer(expression: Expression): JSXExpressionContainer {
    const args = ([].slice: any).call(arguments);
    const loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.JSXExpressionContainer(...args), loc: hasLoc ? (loc: any) : getCurrentLocation()};
  },
  jSXIdentifier(name: string): JSXIdentifier {
    const args = ([].slice: any).call(arguments);
    const loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.JSXIdentifier(...args), loc: hasLoc ? (loc: any) : getCurrentLocation()};
  },
  jSXMemberExpression(object: JSXMemberExpression | JSXIdentifier, property: JSXIdentifier): JSXMemberExpression {
    const args = ([].slice: any).call(arguments);
    const loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.JSXMemberExpression(...args), loc: hasLoc ? (loc: any) : getCurrentLocation()};
  },
  jSXNamespacedName(namespace: JSXIdentifier, name: JSXIdentifier): JSXNamespacedName {
    const args = ([].slice: any).call(arguments);
    const loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.JSXNamespacedName(...args), loc: hasLoc ? (loc: any) : getCurrentLocation()};
  },
  jSXOpeningElement(name: JSXIdentifier | JSXMemberExpression, attributes: $ReadOnlyArray<JSXAttribute | JSXSpreadAttribute>, selfClosing: ?boolean): JSXOpeningElement {
    const args = ([].slice: any).call(arguments);
    const loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.JSXOpeningElement(...args), loc: hasLoc ? (loc: any) : getCurrentLocation()};
  },
  jSXSpreadAttribute(argument: Expression): JSXSpreadAttribute {
    const args = ([].slice: any).call(arguments);
    const loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.JSXSpreadAttribute(...args), loc: hasLoc ? (loc: any) : getCurrentLocation()};
  },
  jSXSpreadChild(expression: Expression): JSXSpreadChild {
    const args = ([].slice: any).call(arguments);
    const loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.JSXSpreadChild(...args), loc: hasLoc ? (loc: any) : getCurrentLocation()};
  },
  jSXText(value: string): JSXText {
    const args = ([].slice: any).call(arguments);
    const loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.JSXText(...args), loc: hasLoc ? (loc: any) : getCurrentLocation()};
  },
  labeledStatement(label: Identifier, body: Statement): LabeledStatement {
    const args = ([].slice: any).call(arguments);
    const loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.LabeledStatement(...args), loc: hasLoc ? (loc: any) : getCurrentLocation()};
  },
  logicalExpression(operator: '||' | '&&', left: Expression, right: Expression): LogicalExpression {
    const args = ([].slice: any).call(arguments);
    const loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.LogicalExpression(...args), loc: hasLoc ? (loc: any) : getCurrentLocation()};
  },
  memberExpression(object: Expression, property: Expression, computed: ?boolean): MemberExpression {
    const args = ([].slice: any).call(arguments);
    const loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.MemberExpression(...args), loc: hasLoc ? (loc: any) : getCurrentLocation()};
  },
  metaProperty(meta: string, property: string): MetaProperty {
    const args = ([].slice: any).call(arguments);
    const loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.MetaProperty(...args), loc: hasLoc ? (loc: any) : getCurrentLocation()};
  },
  mixedTypeAnnotation(): MixedTypeAnnotation {
    const args = ([].slice: any).call(arguments);
    const loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.MixedTypeAnnotation(...args), loc: hasLoc ? (loc: any) : getCurrentLocation()};
  },
  newExpression(callee: Expression, _arguments: $ReadOnlyArray<Expression | SpreadElement>): NewExpression {
    const args = ([].slice: any).call(arguments);
    const loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.NewExpression(...args), loc: hasLoc ? (loc: any) : getCurrentLocation()};
  },
  noop(): Noop {
    const args = ([].slice: any).call(arguments);
    const loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.Noop(...args), loc: hasLoc ? (loc: any) : getCurrentLocation()};
  },
  nullLiteral(): NullLiteral {
    const args = ([].slice: any).call(arguments);
    const loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.NullLiteral(...args), loc: hasLoc ? (loc: any) : getCurrentLocation()};
  },
  nullLiteralTypeAnnotation(): NullLiteralTypeAnnotation {
    const args = ([].slice: any).call(arguments);
    const loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.NullLiteralTypeAnnotation(...args), loc: hasLoc ? (loc: any) : getCurrentLocation()};
  },
  nullableTypeAnnotation(typeAnnotation: mixed): NullableTypeAnnotation {
    const args = ([].slice: any).call(arguments);
    const loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.NullableTypeAnnotation(...args), loc: hasLoc ? (loc: any) : getCurrentLocation()};
  },
  numberTypeAnnotation(): NumberTypeAnnotation {
    const args = ([].slice: any).call(arguments);
    const loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.NumberTypeAnnotation(...args), loc: hasLoc ? (loc: any) : getCurrentLocation()};
  },
  numericLiteral(value: number): NumericLiteral {
    const args = ([].slice: any).call(arguments);
    const loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.NumericLiteral(...args), loc: hasLoc ? (loc: any) : getCurrentLocation()};
  },
  numericLiteralTypeAnnotation(): NumericLiteralTypeAnnotation {
    const args = ([].slice: any).call(arguments);
    const loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.NumericLiteralTypeAnnotation(...args), loc: hasLoc ? (loc: any) : getCurrentLocation()};
  },
  objectExpression(properties: $ReadOnlyArray<ObjectMethod | ObjectProperty | SpreadProperty>): ObjectExpression {
    const args = ([].slice: any).call(arguments);
    const loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.ObjectExpression(...args), loc: hasLoc ? (loc: any) : getCurrentLocation()};
  },
  objectMethod(kind: ?"method" | "get" | "set", key: Expression, params: mixed, body: BlockStatement, computed: ?boolean): ObjectMethod {
    const args = ([].slice: any).call(arguments);
    const loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.ObjectMethod(...args), loc: hasLoc ? (loc: any) : getCurrentLocation()};
  },
  objectPattern(properties: $ReadOnlyArray<RestProperty | Property>, typeAnnotation: mixed): ObjectPattern {
    const args = ([].slice: any).call(arguments);
    const loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.ObjectPattern(...args), loc: hasLoc ? (loc: any) : getCurrentLocation()};
  },
  objectProperty(key: Expression, value: Expression, computed: ?boolean, shorthand: ?boolean, decorators: ?$ReadOnlyArray<Decorator>): ObjectProperty {
    const args = ([].slice: any).call(arguments);
    const loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.ObjectProperty(...args), loc: hasLoc ? (loc: any) : getCurrentLocation()};
  },
  objectTypeAnnotation(properties: mixed, indexers: mixed, callProperties: mixed): ObjectTypeAnnotation {
    const args = ([].slice: any).call(arguments);
    const loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.ObjectTypeAnnotation(...args), loc: hasLoc ? (loc: any) : getCurrentLocation()};
  },
  objectTypeCallProperty(value: mixed): ObjectTypeCallProperty {
    const args = ([].slice: any).call(arguments);
    const loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.ObjectTypeCallProperty(...args), loc: hasLoc ? (loc: any) : getCurrentLocation()};
  },
  objectTypeIndexer(id: mixed, key: mixed, value: mixed): ObjectTypeIndexer {
    const args = ([].slice: any).call(arguments);
    const loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.ObjectTypeIndexer(...args), loc: hasLoc ? (loc: any) : getCurrentLocation()};
  },
  objectTypeProperty(key: mixed, value: mixed): ObjectTypeProperty {
    const args = ([].slice: any).call(arguments);
    const loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.ObjectTypeProperty(...args), loc: hasLoc ? (loc: any) : getCurrentLocation()};
  },
  parenthesizedExpression(expression: Expression): ParenthesizedExpression {
    const args = ([].slice: any).call(arguments);
    const loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.ParenthesizedExpression(...args), loc: hasLoc ? (loc: any) : getCurrentLocation()};
  },
  program(body: $ReadOnlyArray<Statement>, directives: ?$ReadOnlyArray<Directive>): Program {
    const args = ([].slice: any).call(arguments);
    const loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.Program(...args), loc: hasLoc ? (loc: any) : getCurrentLocation()};
  },
  qualifiedTypeIdentifier(id: mixed, qualification: mixed): QualifiedTypeIdentifier {
    const args = ([].slice: any).call(arguments);
    const loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.QualifiedTypeIdentifier(...args), loc: hasLoc ? (loc: any) : getCurrentLocation()};
  },
  regExpLiteral(pattern: string, flags: ?string): RegExpLiteral {
    const args = ([].slice: any).call(arguments);
    const loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.RegExpLiteral(...args), loc: hasLoc ? (loc: any) : getCurrentLocation()};
  },
  restElement(argument: LVal, typeAnnotation: mixed): RestElement {
    const args = ([].slice: any).call(arguments);
    const loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.RestElement(...args), loc: hasLoc ? (loc: any) : getCurrentLocation()};
  },
  restProperty(argument: LVal): RestProperty {
    const args = ([].slice: any).call(arguments);
    const loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.RestProperty(...args), loc: hasLoc ? (loc: any) : getCurrentLocation()};
  },
  returnStatement(argument: ?Expression): ReturnStatement {
    const args = ([].slice: any).call(arguments);
    const loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.ReturnStatement(...args), loc: hasLoc ? (loc: any) : getCurrentLocation()};
  },
  sequenceExpression(expressions: $ReadOnlyArray<Expression>): SequenceExpression {
    const args = ([].slice: any).call(arguments);
    const loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.SequenceExpression(...args), loc: hasLoc ? (loc: any) : getCurrentLocation()};
  },
  spreadElement(argument: Expression): SpreadElement {
    const args = ([].slice: any).call(arguments);
    const loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.SpreadElement(...args), loc: hasLoc ? (loc: any) : getCurrentLocation()};
  },
  spreadProperty(argument: Expression): SpreadProperty {
    const args = ([].slice: any).call(arguments);
    const loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.SpreadProperty(...args), loc: hasLoc ? (loc: any) : getCurrentLocation()};
  },
  stringLiteral(value: string): StringLiteral {
    const args = ([].slice: any).call(arguments);
    const loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.StringLiteral(...args), loc: hasLoc ? (loc: any) : getCurrentLocation()};
  },
  stringLiteralTypeAnnotation(): StringLiteralTypeAnnotation {
    const args = ([].slice: any).call(arguments);
    const loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.StringLiteralTypeAnnotation(...args), loc: hasLoc ? (loc: any) : getCurrentLocation()};
  },
  stringTypeAnnotation(): StringTypeAnnotation {
    const args = ([].slice: any).call(arguments);
    const loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.StringTypeAnnotation(...args), loc: hasLoc ? (loc: any) : getCurrentLocation()};
  },
  super(): Super {
    const args = ([].slice: any).call(arguments);
    const loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.Super(...args), loc: hasLoc ? (loc: any) : getCurrentLocation()};
  },
  switchCase(test: ?Expression, consequent: $ReadOnlyArray<Statement>): SwitchCase {
    const args = ([].slice: any).call(arguments);
    const loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.SwitchCase(...args), loc: hasLoc ? (loc: any) : getCurrentLocation()};
  },
  switchStatement(discriminant: Expression, cases: $ReadOnlyArray<SwitchCase>): SwitchStatement {
    const args = ([].slice: any).call(arguments);
    const loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.SwitchStatement(...args), loc: hasLoc ? (loc: any) : getCurrentLocation()};
  },
  taggedTemplateExpression(tag: Expression, quasi: TemplateLiteral): TaggedTemplateExpression {
    const args = ([].slice: any).call(arguments);
    const loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.TaggedTemplateExpression(...args), loc: hasLoc ? (loc: any) : getCurrentLocation()};
  },
  templateElement(value: mixed, tail: ?boolean): TemplateElement {
    const args = ([].slice: any).call(arguments);
    const loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.TemplateElement(...args), loc: hasLoc ? (loc: any) : getCurrentLocation()};
  },
  templateLiteral(quasis: $ReadOnlyArray<TemplateElement>, expressions: $ReadOnlyArray<Expression>): TemplateLiteral {
    const args = ([].slice: any).call(arguments);
    const loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.TemplateLiteral(...args), loc: hasLoc ? (loc: any) : getCurrentLocation()};
  },
  thisExpression(): ThisExpression {
    const args = ([].slice: any).call(arguments);
    const loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.ThisExpression(...args), loc: hasLoc ? (loc: any) : getCurrentLocation()};
  },
  thisTypeAnnotation(): ThisTypeAnnotation {
    const args = ([].slice: any).call(arguments);
    const loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.ThisTypeAnnotation(...args), loc: hasLoc ? (loc: any) : getCurrentLocation()};
  },
  throwStatement(argument: Expression): ThrowStatement {
    const args = ([].slice: any).call(arguments);
    const loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.ThrowStatement(...args), loc: hasLoc ? (loc: any) : getCurrentLocation()};
  },
  tryStatement(block: mixed, handler: ?mixed, finalizer: ?BlockStatement): TryStatement {
    const args = ([].slice: any).call(arguments);
    const loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.TryStatement(...args), loc: hasLoc ? (loc: any) : getCurrentLocation()};
  },
  tupleTypeAnnotation(types: mixed): TupleTypeAnnotation {
    const args = ([].slice: any).call(arguments);
    const loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.TupleTypeAnnotation(...args), loc: hasLoc ? (loc: any) : getCurrentLocation()};
  },
  typeAlias(id: mixed, typeParameters: mixed, right: mixed): TypeAlias {
    const args = ([].slice: any).call(arguments);
    const loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.TypeAlias(...args), loc: hasLoc ? (loc: any) : getCurrentLocation()};
  },
  typeAnnotation(typeAnnotation: mixed): TypeAnnotation {
    const args = ([].slice: any).call(arguments);
    const loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.TypeAnnotation(...args), loc: hasLoc ? (loc: any) : getCurrentLocation()};
  },
  typeCastExpression(expression: mixed, typeAnnotation: mixed): TypeCastExpression {
    const args = ([].slice: any).call(arguments);
    const loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.TypeCastExpression(...args), loc: hasLoc ? (loc: any) : getCurrentLocation()};
  },
  typeParameter(bound: mixed): TypeParameter {
    const args = ([].slice: any).call(arguments);
    const loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.TypeParameter(...args), loc: hasLoc ? (loc: any) : getCurrentLocation()};
  },
  typeParameterDeclaration(params: mixed): TypeParameterDeclaration {
    const args = ([].slice: any).call(arguments);
    const loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.TypeParameterDeclaration(...args), loc: hasLoc ? (loc: any) : getCurrentLocation()};
  },
  typeParameterInstantiation(params: mixed): TypeParameterInstantiation {
    const args = ([].slice: any).call(arguments);
    const loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.TypeParameterInstantiation(...args), loc: hasLoc ? (loc: any) : getCurrentLocation()};
  },
  typeofTypeAnnotation(argument: mixed): TypeofTypeAnnotation {
    const args = ([].slice: any).call(arguments);
    const loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.TypeofTypeAnnotation(...args), loc: hasLoc ? (loc: any) : getCurrentLocation()};
  },
  unaryExpression(operator: 'void' | 'delete' | '!' | '+' | '-' | '++' | '--' | '~' | 'typeof', argument: Expression, prefix: ?boolean): UnaryExpression {
    const args = ([].slice: any).call(arguments);
    const loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.UnaryExpression(...args), loc: hasLoc ? (loc: any) : getCurrentLocation()};
  },
  unionTypeAnnotation(types: mixed): UnionTypeAnnotation {
    const args = ([].slice: any).call(arguments);
    const loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.UnionTypeAnnotation(...args), loc: hasLoc ? (loc: any) : getCurrentLocation()};
  },
  updateExpression(operator: '++' | '--', argument: Expression, prefix: ?boolean): UpdateExpression {
    const args = ([].slice: any).call(arguments);
    const loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.UpdateExpression(...args), loc: hasLoc ? (loc: any) : getCurrentLocation()};
  },
  variableDeclaration(kind: "var" | "let" | "const", declarations: $ReadOnlyArray<VariableDeclarator>): VariableDeclaration {
    const args = ([].slice: any).call(arguments);
    const loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.VariableDeclaration(...args), loc: hasLoc ? (loc: any) : getCurrentLocation()};
  },
  variableDeclarator(id: LVal, init: ?Expression): VariableDeclarator {
    const args = ([].slice: any).call(arguments);
    const loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.VariableDeclarator(...args), loc: hasLoc ? (loc: any) : getCurrentLocation()};
  },
  voidTypeAnnotation(): VoidTypeAnnotation {
    const args = ([].slice: any).call(arguments);
    const loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.VoidTypeAnnotation(...args), loc: hasLoc ? (loc: any) : getCurrentLocation()};
  },
  whileStatement(test: Expression, body: BlockStatement | Statement): WhileStatement {
    const args = ([].slice: any).call(arguments);
    const loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.WhileStatement(...args), loc: hasLoc ? (loc: any) : getCurrentLocation()};
  },
  withStatement(object: mixed, body: BlockStatement | Statement): WithStatement {
    const args = ([].slice: any).call(arguments);
    const loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.WithStatement(...args), loc: hasLoc ? (loc: any) : getCurrentLocation()};
  },
  yieldExpression(argument: ?Expression, delegate: ?boolean): YieldExpression {
    const args = ([].slice: any).call(arguments);
    const loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.YieldExpression(...args), loc: hasLoc ? (loc: any) : getCurrentLocation()};
  },
  isAnyTypeAnnotation(value: any, opts?: Object): boolean {
    return t.isAnyTypeAnnotation(...arguments);
  },
  isArrayExpression(value: any, opts?: Object): boolean {
    return t.isArrayExpression(...arguments);
  },
  isArrayPattern(value: any, opts?: Object): boolean {
    return t.isArrayPattern(...arguments);
  },
  isArrayTypeAnnotation(value: any, opts?: Object): boolean {
    return t.isArrayTypeAnnotation(...arguments);
  },
  isArrowFunctionExpression(value: any, opts?: Object): boolean {
    return t.isArrowFunctionExpression(...arguments);
  },
  isAssignmentExpression(value: any, opts?: Object): boolean {
    return t.isAssignmentExpression(...arguments);
  },
  isAssignmentPattern(value: any, opts?: Object): boolean {
    return t.isAssignmentPattern(...arguments);
  },
  isAwaitExpression(value: any, opts?: Object): boolean {
    return t.isAwaitExpression(...arguments);
  },
  isBinaryExpression(value: any, opts?: Object): boolean {
    return t.isBinaryExpression(...arguments);
  },
  isBindExpression(value: any, opts?: Object): boolean {
    return t.isBindExpression(...arguments);
  },
  isBlockStatement(value: any, opts?: Object): boolean {
    return t.isBlockStatement(...arguments);
  },
  isBooleanLiteral(value: any, opts?: Object): boolean {
    return t.isBooleanLiteral(...arguments);
  },
  isBooleanLiteralTypeAnnotation(value: any, opts?: Object): boolean {
    return t.isBooleanLiteralTypeAnnotation(...arguments);
  },
  isBooleanTypeAnnotation(value: any, opts?: Object): boolean {
    return t.isBooleanTypeAnnotation(...arguments);
  },
  isBreakStatement(value: any, opts?: Object): boolean {
    return t.isBreakStatement(...arguments);
  },
  isCallExpression(value: any, opts?: Object): boolean {
    return t.isCallExpression(...arguments);
  },
  isCatchClause(value: any, opts?: Object): boolean {
    return t.isCatchClause(...arguments);
  },
  isClassBody(value: any, opts?: Object): boolean {
    return t.isClassBody(...arguments);
  },
  isClassDeclaration(value: any, opts?: Object): boolean {
    return t.isClassDeclaration(...arguments);
  },
  isClassExpression(value: any, opts?: Object): boolean {
    return t.isClassExpression(...arguments);
  },
  isClassImplements(value: any, opts?: Object): boolean {
    return t.isClassImplements(...arguments);
  },
  isClassMethod(value: any, opts?: Object): boolean {
    return t.isClassMethod(...arguments);
  },
  isClassProperty(value: any, opts?: Object): boolean {
    return t.isClassProperty(...arguments);
  },
  isConditionalExpression(value: any, opts?: Object): boolean {
    return t.isConditionalExpression(...arguments);
  },
  isContinueStatement(value: any, opts?: Object): boolean {
    return t.isContinueStatement(...arguments);
  },
  isDebuggerStatement(value: any, opts?: Object): boolean {
    return t.isDebuggerStatement(...arguments);
  },
  isDeclareClass(value: any, opts?: Object): boolean {
    return t.isDeclareClass(...arguments);
  },
  isDeclareFunction(value: any, opts?: Object): boolean {
    return t.isDeclareFunction(...arguments);
  },
  isDeclareInterface(value: any, opts?: Object): boolean {
    return t.isDeclareInterface(...arguments);
  },
  isDeclareModule(value: any, opts?: Object): boolean {
    return t.isDeclareModule(...arguments);
  },
  isDeclareModuleExports(value: any, opts?: Object): boolean {
    return t.isDeclareModuleExports(...arguments);
  },
  isDeclareTypeAlias(value: any, opts?: Object): boolean {
    return t.isDeclareTypeAlias(...arguments);
  },
  isDeclareVariable(value: any, opts?: Object): boolean {
    return t.isDeclareVariable(...arguments);
  },
  isDecorator(value: any, opts?: Object): boolean {
    return t.isDecorator(...arguments);
  },
  isDirective(value: any, opts?: Object): boolean {
    return t.isDirective(...arguments);
  },
  isDirectiveLiteral(value: any, opts?: Object): boolean {
    return t.isDirectiveLiteral(...arguments);
  },
  isDoExpression(value: any, opts?: Object): boolean {
    return t.isDoExpression(...arguments);
  },
  isDoWhileStatement(value: any, opts?: Object): boolean {
    return t.isDoWhileStatement(...arguments);
  },
  isEmptyStatement(value: any, opts?: Object): boolean {
    return t.isEmptyStatement(...arguments);
  },
  isEmptyTypeAnnotation(value: any, opts?: Object): boolean {
    return t.isEmptyTypeAnnotation(...arguments);
  },
  isExistentialTypeParam(value: any, opts?: Object): boolean {
    return t.isExistentialTypeParam(...arguments);
  },
  isExportAllDeclaration(value: any, opts?: Object): boolean {
    return t.isExportAllDeclaration(...arguments);
  },
  isExportDefaultDeclaration(value: any, opts?: Object): boolean {
    return t.isExportDefaultDeclaration(...arguments);
  },
  isExportDefaultSpecifier(value: any, opts?: Object): boolean {
    return t.isExportDefaultSpecifier(...arguments);
  },
  isExportNamedDeclaration(value: any, opts?: Object): boolean {
    return t.isExportNamedDeclaration(...arguments);
  },
  isExportNamespaceSpecifier(value: any, opts?: Object): boolean {
    return t.isExportNamespaceSpecifier(...arguments);
  },
  isExportSpecifier(value: any, opts?: Object): boolean {
    return t.isExportSpecifier(...arguments);
  },
  isExpressionStatement(value: any, opts?: Object): boolean {
    return t.isExpressionStatement(...arguments);
  },
  isFile(value: any, opts?: Object): boolean {
    return t.isFile(...arguments);
  },
  isForAwaitStatement(value: any, opts?: Object): boolean {
    return t.isForAwaitStatement(...arguments);
  },
  isForInStatement(value: any, opts?: Object): boolean {
    return t.isForInStatement(...arguments);
  },
  isForOfStatement(value: any, opts?: Object): boolean {
    return t.isForOfStatement(...arguments);
  },
  isForStatement(value: any, opts?: Object): boolean {
    return t.isForStatement(...arguments);
  },
  isFunctionDeclaration(value: any, opts?: Object): boolean {
    return t.isFunctionDeclaration(...arguments);
  },
  isFunctionExpression(value: any, opts?: Object): boolean {
    return t.isFunctionExpression(...arguments);
  },
  isFunctionTypeAnnotation(value: any, opts?: Object): boolean {
    return t.isFunctionTypeAnnotation(...arguments);
  },
  isFunctionTypeParam(value: any, opts?: Object): boolean {
    return t.isFunctionTypeParam(...arguments);
  },
  isGenericTypeAnnotation(value: any, opts?: Object): boolean {
    return t.isGenericTypeAnnotation(...arguments);
  },
  isIdentifier(value: any, opts?: Object): boolean {
    return t.isIdentifier(...arguments);
  },
  isIfStatement(value: any, opts?: Object): boolean {
    return t.isIfStatement(...arguments);
  },
  isImport(value: any, opts?: Object): boolean {
    return t.isImport(...arguments);
  },
  isImportDeclaration(value: any, opts?: Object): boolean {
    return t.isImportDeclaration(...arguments);
  },
  isImportDefaultSpecifier(value: any, opts?: Object): boolean {
    return t.isImportDefaultSpecifier(...arguments);
  },
  isImportNamespaceSpecifier(value: any, opts?: Object): boolean {
    return t.isImportNamespaceSpecifier(...arguments);
  },
  isImportSpecifier(value: any, opts?: Object): boolean {
    return t.isImportSpecifier(...arguments);
  },
  isInterfaceDeclaration(value: any, opts?: Object): boolean {
    return t.isInterfaceDeclaration(...arguments);
  },
  isInterfaceExtends(value: any, opts?: Object): boolean {
    return t.isInterfaceExtends(...arguments);
  },
  isIntersectionTypeAnnotation(value: any, opts?: Object): boolean {
    return t.isIntersectionTypeAnnotation(...arguments);
  },
  isJSXAttribute(value: any, opts?: Object): boolean {
    return t.isJSXAttribute(...arguments);
  },
  isJSXClosingElement(value: any, opts?: Object): boolean {
    return t.isJSXClosingElement(...arguments);
  },
  isJSXElement(value: any, opts?: Object): boolean {
    return t.isJSXElement(...arguments);
  },
  isJSXEmptyExpression(value: any, opts?: Object): boolean {
    return t.isJSXEmptyExpression(...arguments);
  },
  isJSXExpressionContainer(value: any, opts?: Object): boolean {
    return t.isJSXExpressionContainer(...arguments);
  },
  isJSXIdentifier(value: any, opts?: Object): boolean {
    return t.isJSXIdentifier(...arguments);
  },
  isJSXMemberExpression(value: any, opts?: Object): boolean {
    return t.isJSXMemberExpression(...arguments);
  },
  isJSXNamespacedName(value: any, opts?: Object): boolean {
    return t.isJSXNamespacedName(...arguments);
  },
  isJSXOpeningElement(value: any, opts?: Object): boolean {
    return t.isJSXOpeningElement(...arguments);
  },
  isJSXSpreadAttribute(value: any, opts?: Object): boolean {
    return t.isJSXSpreadAttribute(...arguments);
  },
  isJSXSpreadChild(value: any, opts?: Object): boolean {
    return t.isJSXSpreadChild(...arguments);
  },
  isJSXText(value: any, opts?: Object): boolean {
    return t.isJSXText(...arguments);
  },
  isLabeledStatement(value: any, opts?: Object): boolean {
    return t.isLabeledStatement(...arguments);
  },
  isLogicalExpression(value: any, opts?: Object): boolean {
    return t.isLogicalExpression(...arguments);
  },
  isMemberExpression(value: any, opts?: Object): boolean {
    return t.isMemberExpression(...arguments);
  },
  isMetaProperty(value: any, opts?: Object): boolean {
    return t.isMetaProperty(...arguments);
  },
  isMixedTypeAnnotation(value: any, opts?: Object): boolean {
    return t.isMixedTypeAnnotation(...arguments);
  },
  isNewExpression(value: any, opts?: Object): boolean {
    return t.isNewExpression(...arguments);
  },
  isNoop(value: any, opts?: Object): boolean {
    return t.isNoop(...arguments);
  },
  isNullLiteral(value: any, opts?: Object): boolean {
    return t.isNullLiteral(...arguments);
  },
  isNullLiteralTypeAnnotation(value: any, opts?: Object): boolean {
    return t.isNullLiteralTypeAnnotation(...arguments);
  },
  isNullableTypeAnnotation(value: any, opts?: Object): boolean {
    return t.isNullableTypeAnnotation(...arguments);
  },
  isNumberTypeAnnotation(value: any, opts?: Object): boolean {
    return t.isNumberTypeAnnotation(...arguments);
  },
  isNumericLiteral(value: any, opts?: Object): boolean {
    return t.isNumericLiteral(...arguments);
  },
  isNumericLiteralTypeAnnotation(value: any, opts?: Object): boolean {
    return t.isNumericLiteralTypeAnnotation(...arguments);
  },
  isObjectExpression(value: any, opts?: Object): boolean {
    return t.isObjectExpression(...arguments);
  },
  isObjectMethod(value: any, opts?: Object): boolean {
    return t.isObjectMethod(...arguments);
  },
  isObjectPattern(value: any, opts?: Object): boolean {
    return t.isObjectPattern(...arguments);
  },
  isObjectProperty(value: any, opts?: Object): boolean {
    return t.isObjectProperty(...arguments);
  },
  isObjectTypeAnnotation(value: any, opts?: Object): boolean {
    return t.isObjectTypeAnnotation(...arguments);
  },
  isObjectTypeCallProperty(value: any, opts?: Object): boolean {
    return t.isObjectTypeCallProperty(...arguments);
  },
  isObjectTypeIndexer(value: any, opts?: Object): boolean {
    return t.isObjectTypeIndexer(...arguments);
  },
  isObjectTypeProperty(value: any, opts?: Object): boolean {
    return t.isObjectTypeProperty(...arguments);
  },
  isParenthesizedExpression(value: any, opts?: Object): boolean {
    return t.isParenthesizedExpression(...arguments);
  },
  isProgram(value: any, opts?: Object): boolean {
    return t.isProgram(...arguments);
  },
  isQualifiedTypeIdentifier(value: any, opts?: Object): boolean {
    return t.isQualifiedTypeIdentifier(...arguments);
  },
  isRegExpLiteral(value: any, opts?: Object): boolean {
    return t.isRegExpLiteral(...arguments);
  },
  isRestElement(value: any, opts?: Object): boolean {
    return t.isRestElement(...arguments);
  },
  isRestProperty(value: any, opts?: Object): boolean {
    return t.isRestProperty(...arguments);
  },
  isReturnStatement(value: any, opts?: Object): boolean {
    return t.isReturnStatement(...arguments);
  },
  isSequenceExpression(value: any, opts?: Object): boolean {
    return t.isSequenceExpression(...arguments);
  },
  isSpreadElement(value: any, opts?: Object): boolean {
    return t.isSpreadElement(...arguments);
  },
  isSpreadProperty(value: any, opts?: Object): boolean {
    return t.isSpreadProperty(...arguments);
  },
  isStringLiteral(value: any, opts?: Object): boolean {
    return t.isStringLiteral(...arguments);
  },
  isStringLiteralTypeAnnotation(value: any, opts?: Object): boolean {
    return t.isStringLiteralTypeAnnotation(...arguments);
  },
  isStringTypeAnnotation(value: any, opts?: Object): boolean {
    return t.isStringTypeAnnotation(...arguments);
  },
  isSuper(value: any, opts?: Object): boolean {
    return t.isSuper(...arguments);
  },
  isSwitchCase(value: any, opts?: Object): boolean {
    return t.isSwitchCase(...arguments);
  },
  isSwitchStatement(value: any, opts?: Object): boolean {
    return t.isSwitchStatement(...arguments);
  },
  isTaggedTemplateExpression(value: any, opts?: Object): boolean {
    return t.isTaggedTemplateExpression(...arguments);
  },
  isTemplateElement(value: any, opts?: Object): boolean {
    return t.isTemplateElement(...arguments);
  },
  isTemplateLiteral(value: any, opts?: Object): boolean {
    return t.isTemplateLiteral(...arguments);
  },
  isThisExpression(value: any, opts?: Object): boolean {
    return t.isThisExpression(...arguments);
  },
  isThisTypeAnnotation(value: any, opts?: Object): boolean {
    return t.isThisTypeAnnotation(...arguments);
  },
  isThrowStatement(value: any, opts?: Object): boolean {
    return t.isThrowStatement(...arguments);
  },
  isTryStatement(value: any, opts?: Object): boolean {
    return t.isTryStatement(...arguments);
  },
  isTupleTypeAnnotation(value: any, opts?: Object): boolean {
    return t.isTupleTypeAnnotation(...arguments);
  },
  isTypeAlias(value: any, opts?: Object): boolean {
    return t.isTypeAlias(...arguments);
  },
  isTypeAnnotation(value: any, opts?: Object): boolean {
    return t.isTypeAnnotation(...arguments);
  },
  isTypeCastExpression(value: any, opts?: Object): boolean {
    return t.isTypeCastExpression(...arguments);
  },
  isTypeParameter(value: any, opts?: Object): boolean {
    return t.isTypeParameter(...arguments);
  },
  isTypeParameterDeclaration(value: any, opts?: Object): boolean {
    return t.isTypeParameterDeclaration(...arguments);
  },
  isTypeParameterInstantiation(value: any, opts?: Object): boolean {
    return t.isTypeParameterInstantiation(...arguments);
  },
  isTypeofTypeAnnotation(value: any, opts?: Object): boolean {
    return t.isTypeofTypeAnnotation(...arguments);
  },
  isUnaryExpression(value: any, opts?: Object): boolean {
    return t.isUnaryExpression(...arguments);
  },
  isUnionTypeAnnotation(value: any, opts?: Object): boolean {
    return t.isUnionTypeAnnotation(...arguments);
  },
  isUpdateExpression(value: any, opts?: Object): boolean {
    return t.isUpdateExpression(...arguments);
  },
  isVariableDeclaration(value: any, opts?: Object): boolean {
    return t.isVariableDeclaration(...arguments);
  },
  isVariableDeclarator(value: any, opts?: Object): boolean {
    return t.isVariableDeclarator(...arguments);
  },
  isVoidTypeAnnotation(value: any, opts?: Object): boolean {
    return t.isVoidTypeAnnotation(...arguments);
  },
  isWhileStatement(value: any, opts?: Object): boolean {
    return t.isWhileStatement(...arguments);
  },
  isWithStatement(value: any, opts?: Object): boolean {
    return t.isWithStatement(...arguments);
  },
  isYieldExpression(value: any, opts?: Object): boolean {
    return t.isYieldExpression(...arguments);
  },
  assertAnyTypeAnnotation(value: AnyTypeAnnotation, opts?: Object): mixed {
    return t.assertAnyTypeAnnotation(...arguments);
  },
  assertArrayExpression(value: ArrayExpression, opts?: Object): mixed {
    return t.assertArrayExpression(...arguments);
  },
  assertArrayPattern(value: ArrayPattern, opts?: Object): mixed {
    return t.assertArrayPattern(...arguments);
  },
  assertArrayTypeAnnotation(value: ArrayTypeAnnotation, opts?: Object): mixed {
    return t.assertArrayTypeAnnotation(...arguments);
  },
  assertArrowFunctionExpression(value: ArrowFunctionExpression, opts?: Object): mixed {
    return t.assertArrowFunctionExpression(...arguments);
  },
  assertAssignmentExpression(value: AssignmentExpression, opts?: Object): mixed {
    return t.assertAssignmentExpression(...arguments);
  },
  assertAssignmentPattern(value: AssignmentPattern, opts?: Object): mixed {
    return t.assertAssignmentPattern(...arguments);
  },
  assertAwaitExpression(value: AwaitExpression, opts?: Object): mixed {
    return t.assertAwaitExpression(...arguments);
  },
  assertBinaryExpression(value: BinaryExpression, opts?: Object): mixed {
    return t.assertBinaryExpression(...arguments);
  },
  assertBindExpression(value: BindExpression, opts?: Object): mixed {
    return t.assertBindExpression(...arguments);
  },
  assertBlockStatement(value: BlockStatement, opts?: Object): mixed {
    return t.assertBlockStatement(...arguments);
  },
  assertBooleanLiteral(value: BooleanLiteral, opts?: Object): mixed {
    return t.assertBooleanLiteral(...arguments);
  },
  assertBooleanLiteralTypeAnnotation(value: BooleanLiteralTypeAnnotation, opts?: Object): mixed {
    return t.assertBooleanLiteralTypeAnnotation(...arguments);
  },
  assertBooleanTypeAnnotation(value: BooleanTypeAnnotation, opts?: Object): mixed {
    return t.assertBooleanTypeAnnotation(...arguments);
  },
  assertBreakStatement(value: BreakStatement, opts?: Object): mixed {
    return t.assertBreakStatement(...arguments);
  },
  assertCallExpression(value: CallExpression, opts?: Object): mixed {
    return t.assertCallExpression(...arguments);
  },
  assertCatchClause(value: CatchClause, opts?: Object): mixed {
    return t.assertCatchClause(...arguments);
  },
  assertClassBody(value: ClassBody, opts?: Object): mixed {
    return t.assertClassBody(...arguments);
  },
  assertClassDeclaration(value: ClassDeclaration, opts?: Object): mixed {
    return t.assertClassDeclaration(...arguments);
  },
  assertClassExpression(value: ClassExpression, opts?: Object): mixed {
    return t.assertClassExpression(...arguments);
  },
  assertClassImplements(value: ClassImplements, opts?: Object): mixed {
    return t.assertClassImplements(...arguments);
  },
  assertClassMethod(value: ClassMethod, opts?: Object): mixed {
    return t.assertClassMethod(...arguments);
  },
  assertClassProperty(value: ClassProperty, opts?: Object): mixed {
    return t.assertClassProperty(...arguments);
  },
  assertConditionalExpression(value: ConditionalExpression, opts?: Object): mixed {
    return t.assertConditionalExpression(...arguments);
  },
  assertContinueStatement(value: ContinueStatement, opts?: Object): mixed {
    return t.assertContinueStatement(...arguments);
  },
  assertDebuggerStatement(value: DebuggerStatement, opts?: Object): mixed {
    return t.assertDebuggerStatement(...arguments);
  },
  assertDeclareClass(value: DeclareClass, opts?: Object): mixed {
    return t.assertDeclareClass(...arguments);
  },
  assertDeclareFunction(value: DeclareFunction, opts?: Object): mixed {
    return t.assertDeclareFunction(...arguments);
  },
  assertDeclareInterface(value: DeclareInterface, opts?: Object): mixed {
    return t.assertDeclareInterface(...arguments);
  },
  assertDeclareModule(value: DeclareModule, opts?: Object): mixed {
    return t.assertDeclareModule(...arguments);
  },
  assertDeclareModuleExports(value: DeclareModuleExports, opts?: Object): mixed {
    return t.assertDeclareModuleExports(...arguments);
  },
  assertDeclareTypeAlias(value: DeclareTypeAlias, opts?: Object): mixed {
    return t.assertDeclareTypeAlias(...arguments);
  },
  assertDeclareVariable(value: DeclareVariable, opts?: Object): mixed {
    return t.assertDeclareVariable(...arguments);
  },
  assertDecorator(value: Decorator, opts?: Object): mixed {
    return t.assertDecorator(...arguments);
  },
  assertDirective(value: Directive, opts?: Object): mixed {
    return t.assertDirective(...arguments);
  },
  assertDirectiveLiteral(value: DirectiveLiteral, opts?: Object): mixed {
    return t.assertDirectiveLiteral(...arguments);
  },
  assertDoExpression(value: DoExpression, opts?: Object): mixed {
    return t.assertDoExpression(...arguments);
  },
  assertDoWhileStatement(value: DoWhileStatement, opts?: Object): mixed {
    return t.assertDoWhileStatement(...arguments);
  },
  assertEmptyStatement(value: EmptyStatement, opts?: Object): mixed {
    return t.assertEmptyStatement(...arguments);
  },
  assertEmptyTypeAnnotation(value: EmptyTypeAnnotation, opts?: Object): mixed {
    return t.assertEmptyTypeAnnotation(...arguments);
  },
  assertExistentialTypeParam(value: ExistentialTypeParam, opts?: Object): mixed {
    return t.assertExistentialTypeParam(...arguments);
  },
  assertExportAllDeclaration(value: ExportAllDeclaration, opts?: Object): mixed {
    return t.assertExportAllDeclaration(...arguments);
  },
  assertExportDefaultDeclaration(value: ExportDefaultDeclaration, opts?: Object): mixed {
    return t.assertExportDefaultDeclaration(...arguments);
  },
  assertExportDefaultSpecifier(value: ExportDefaultSpecifier, opts?: Object): mixed {
    return t.assertExportDefaultSpecifier(...arguments);
  },
  assertExportNamedDeclaration(value: ExportNamedDeclaration, opts?: Object): mixed {
    return t.assertExportNamedDeclaration(...arguments);
  },
  assertExportNamespaceSpecifier(value: ExportNamespaceSpecifier, opts?: Object): mixed {
    return t.assertExportNamespaceSpecifier(...arguments);
  },
  assertExportSpecifier(value: ExportSpecifier, opts?: Object): mixed {
    return t.assertExportSpecifier(...arguments);
  },
  assertExpressionStatement(value: ExpressionStatement, opts?: Object): mixed {
    return t.assertExpressionStatement(...arguments);
  },
  assertFile(value: File, opts?: Object): mixed {
    return t.assertFile(...arguments);
  },
  assertForAwaitStatement(value: ForAwaitStatement, opts?: Object): mixed {
    return t.assertForAwaitStatement(...arguments);
  },
  assertForInStatement(value: ForInStatement, opts?: Object): mixed {
    return t.assertForInStatement(...arguments);
  },
  assertForOfStatement(value: ForOfStatement, opts?: Object): mixed {
    return t.assertForOfStatement(...arguments);
  },
  assertForStatement(value: ForStatement, opts?: Object): mixed {
    return t.assertForStatement(...arguments);
  },
  assertFunctionDeclaration(value: FunctionDeclaration, opts?: Object): mixed {
    return t.assertFunctionDeclaration(...arguments);
  },
  assertFunctionExpression(value: FunctionExpression, opts?: Object): mixed {
    return t.assertFunctionExpression(...arguments);
  },
  assertFunctionTypeAnnotation(value: FunctionTypeAnnotation, opts?: Object): mixed {
    return t.assertFunctionTypeAnnotation(...arguments);
  },
  assertFunctionTypeParam(value: FunctionTypeParam, opts?: Object): mixed {
    return t.assertFunctionTypeParam(...arguments);
  },
  assertGenericTypeAnnotation(value: GenericTypeAnnotation, opts?: Object): mixed {
    return t.assertGenericTypeAnnotation(...arguments);
  },
  assertIdentifier(value: Identifier, opts?: Object): mixed {
    return t.assertIdentifier(...arguments);
  },
  assertIfStatement(value: IfStatement, opts?: Object): mixed {
    return t.assertIfStatement(...arguments);
  },
  assertImport(value: Import, opts?: Object): mixed {
    return t.assertImport(...arguments);
  },
  assertImportDeclaration(value: ImportDeclaration, opts?: Object): mixed {
    return t.assertImportDeclaration(...arguments);
  },
  assertImportDefaultSpecifier(value: ImportDefaultSpecifier, opts?: Object): mixed {
    return t.assertImportDefaultSpecifier(...arguments);
  },
  assertImportNamespaceSpecifier(value: ImportNamespaceSpecifier, opts?: Object): mixed {
    return t.assertImportNamespaceSpecifier(...arguments);
  },
  assertImportSpecifier(value: ImportSpecifier, opts?: Object): mixed {
    return t.assertImportSpecifier(...arguments);
  },
  assertInterfaceDeclaration(value: InterfaceDeclaration, opts?: Object): mixed {
    return t.assertInterfaceDeclaration(...arguments);
  },
  assertInterfaceExtends(value: InterfaceExtends, opts?: Object): mixed {
    return t.assertInterfaceExtends(...arguments);
  },
  assertIntersectionTypeAnnotation(value: IntersectionTypeAnnotation, opts?: Object): mixed {
    return t.assertIntersectionTypeAnnotation(...arguments);
  },
  assertJSXAttribute(value: JSXAttribute, opts?: Object): mixed {
    return t.assertJSXAttribute(...arguments);
  },
  assertJSXClosingElement(value: JSXClosingElement, opts?: Object): mixed {
    return t.assertJSXClosingElement(...arguments);
  },
  assertJSXElement(value: JSXElement, opts?: Object): mixed {
    return t.assertJSXElement(...arguments);
  },
  assertJSXEmptyExpression(value: JSXEmptyExpression, opts?: Object): mixed {
    return t.assertJSXEmptyExpression(...arguments);
  },
  assertJSXExpressionContainer(value: JSXExpressionContainer, opts?: Object): mixed {
    return t.assertJSXExpressionContainer(...arguments);
  },
  assertJSXIdentifier(value: JSXIdentifier, opts?: Object): mixed {
    return t.assertJSXIdentifier(...arguments);
  },
  assertJSXMemberExpression(value: JSXMemberExpression, opts?: Object): mixed {
    return t.assertJSXMemberExpression(...arguments);
  },
  assertJSXNamespacedName(value: JSXNamespacedName, opts?: Object): mixed {
    return t.assertJSXNamespacedName(...arguments);
  },
  assertJSXOpeningElement(value: JSXOpeningElement, opts?: Object): mixed {
    return t.assertJSXOpeningElement(...arguments);
  },
  assertJSXSpreadAttribute(value: JSXSpreadAttribute, opts?: Object): mixed {
    return t.assertJSXSpreadAttribute(...arguments);
  },
  assertJSXSpreadChild(value: JSXSpreadChild, opts?: Object): mixed {
    return t.assertJSXSpreadChild(...arguments);
  },
  assertJSXText(value: JSXText, opts?: Object): mixed {
    return t.assertJSXText(...arguments);
  },
  assertLabeledStatement(value: LabeledStatement, opts?: Object): mixed {
    return t.assertLabeledStatement(...arguments);
  },
  assertLogicalExpression(value: LogicalExpression, opts?: Object): mixed {
    return t.assertLogicalExpression(...arguments);
  },
  assertMemberExpression(value: MemberExpression, opts?: Object): mixed {
    return t.assertMemberExpression(...arguments);
  },
  assertMetaProperty(value: MetaProperty, opts?: Object): mixed {
    return t.assertMetaProperty(...arguments);
  },
  assertMixedTypeAnnotation(value: MixedTypeAnnotation, opts?: Object): mixed {
    return t.assertMixedTypeAnnotation(...arguments);
  },
  assertNewExpression(value: NewExpression, opts?: Object): mixed {
    return t.assertNewExpression(...arguments);
  },
  assertNoop(value: Noop, opts?: Object): mixed {
    return t.assertNoop(...arguments);
  },
  assertNullLiteral(value: NullLiteral, opts?: Object): mixed {
    return t.assertNullLiteral(...arguments);
  },
  assertNullLiteralTypeAnnotation(value: NullLiteralTypeAnnotation, opts?: Object): mixed {
    return t.assertNullLiteralTypeAnnotation(...arguments);
  },
  assertNullableTypeAnnotation(value: NullableTypeAnnotation, opts?: Object): mixed {
    return t.assertNullableTypeAnnotation(...arguments);
  },
  assertNumberTypeAnnotation(value: NumberTypeAnnotation, opts?: Object): mixed {
    return t.assertNumberTypeAnnotation(...arguments);
  },
  assertNumericLiteral(value: NumericLiteral, opts?: Object): mixed {
    return t.assertNumericLiteral(...arguments);
  },
  assertNumericLiteralTypeAnnotation(value: NumericLiteralTypeAnnotation, opts?: Object): mixed {
    return t.assertNumericLiteralTypeAnnotation(...arguments);
  },
  assertObjectExpression(value: ObjectExpression, opts?: Object): mixed {
    return t.assertObjectExpression(...arguments);
  },
  assertObjectMethod(value: ObjectMethod, opts?: Object): mixed {
    return t.assertObjectMethod(...arguments);
  },
  assertObjectPattern(value: ObjectPattern, opts?: Object): mixed {
    return t.assertObjectPattern(...arguments);
  },
  assertObjectProperty(value: ObjectProperty, opts?: Object): mixed {
    return t.assertObjectProperty(...arguments);
  },
  assertObjectTypeAnnotation(value: ObjectTypeAnnotation, opts?: Object): mixed {
    return t.assertObjectTypeAnnotation(...arguments);
  },
  assertObjectTypeCallProperty(value: ObjectTypeCallProperty, opts?: Object): mixed {
    return t.assertObjectTypeCallProperty(...arguments);
  },
  assertObjectTypeIndexer(value: ObjectTypeIndexer, opts?: Object): mixed {
    return t.assertObjectTypeIndexer(...arguments);
  },
  assertObjectTypeProperty(value: ObjectTypeProperty, opts?: Object): mixed {
    return t.assertObjectTypeProperty(...arguments);
  },
  assertParenthesizedExpression(value: ParenthesizedExpression, opts?: Object): mixed {
    return t.assertParenthesizedExpression(...arguments);
  },
  assertProgram(value: Program, opts?: Object): mixed {
    return t.assertProgram(...arguments);
  },
  assertQualifiedTypeIdentifier(value: QualifiedTypeIdentifier, opts?: Object): mixed {
    return t.assertQualifiedTypeIdentifier(...arguments);
  },
  assertRegExpLiteral(value: RegExpLiteral, opts?: Object): mixed {
    return t.assertRegExpLiteral(...arguments);
  },
  assertRestElement(value: RestElement, opts?: Object): mixed {
    return t.assertRestElement(...arguments);
  },
  assertRestProperty(value: RestProperty, opts?: Object): mixed {
    return t.assertRestProperty(...arguments);
  },
  assertReturnStatement(value: ReturnStatement, opts?: Object): mixed {
    return t.assertReturnStatement(...arguments);
  },
  assertSequenceExpression(value: SequenceExpression, opts?: Object): mixed {
    return t.assertSequenceExpression(...arguments);
  },
  assertSpreadElement(value: SpreadElement, opts?: Object): mixed {
    return t.assertSpreadElement(...arguments);
  },
  assertSpreadProperty(value: SpreadProperty, opts?: Object): mixed {
    return t.assertSpreadProperty(...arguments);
  },
  assertStringLiteral(value: StringLiteral, opts?: Object): mixed {
    return t.assertStringLiteral(...arguments);
  },
  assertStringLiteralTypeAnnotation(value: StringLiteralTypeAnnotation, opts?: Object): mixed {
    return t.assertStringLiteralTypeAnnotation(...arguments);
  },
  assertStringTypeAnnotation(value: StringTypeAnnotation, opts?: Object): mixed {
    return t.assertStringTypeAnnotation(...arguments);
  },
  assertSuper(value: Super, opts?: Object): mixed {
    return t.assertSuper(...arguments);
  },
  assertSwitchCase(value: SwitchCase, opts?: Object): mixed {
    return t.assertSwitchCase(...arguments);
  },
  assertSwitchStatement(value: SwitchStatement, opts?: Object): mixed {
    return t.assertSwitchStatement(...arguments);
  },
  assertTaggedTemplateExpression(value: TaggedTemplateExpression, opts?: Object): mixed {
    return t.assertTaggedTemplateExpression(...arguments);
  },
  assertTemplateElement(value: TemplateElement, opts?: Object): mixed {
    return t.assertTemplateElement(...arguments);
  },
  assertTemplateLiteral(value: TemplateLiteral, opts?: Object): mixed {
    return t.assertTemplateLiteral(...arguments);
  },
  assertThisExpression(value: ThisExpression, opts?: Object): mixed {
    return t.assertThisExpression(...arguments);
  },
  assertThisTypeAnnotation(value: ThisTypeAnnotation, opts?: Object): mixed {
    return t.assertThisTypeAnnotation(...arguments);
  },
  assertThrowStatement(value: ThrowStatement, opts?: Object): mixed {
    return t.assertThrowStatement(...arguments);
  },
  assertTryStatement(value: TryStatement, opts?: Object): mixed {
    return t.assertTryStatement(...arguments);
  },
  assertTupleTypeAnnotation(value: TupleTypeAnnotation, opts?: Object): mixed {
    return t.assertTupleTypeAnnotation(...arguments);
  },
  assertTypeAlias(value: TypeAlias, opts?: Object): mixed {
    return t.assertTypeAlias(...arguments);
  },
  assertTypeAnnotation(value: TypeAnnotation, opts?: Object): mixed {
    return t.assertTypeAnnotation(...arguments);
  },
  assertTypeCastExpression(value: TypeCastExpression, opts?: Object): mixed {
    return t.assertTypeCastExpression(...arguments);
  },
  assertTypeParameter(value: TypeParameter, opts?: Object): mixed {
    return t.assertTypeParameter(...arguments);
  },
  assertTypeParameterDeclaration(value: TypeParameterDeclaration, opts?: Object): mixed {
    return t.assertTypeParameterDeclaration(...arguments);
  },
  assertTypeParameterInstantiation(value: TypeParameterInstantiation, opts?: Object): mixed {
    return t.assertTypeParameterInstantiation(...arguments);
  },
  assertTypeofTypeAnnotation(value: TypeofTypeAnnotation, opts?: Object): mixed {
    return t.assertTypeofTypeAnnotation(...arguments);
  },
  assertUnaryExpression(value: UnaryExpression, opts?: Object): mixed {
    return t.assertUnaryExpression(...arguments);
  },
  assertUnionTypeAnnotation(value: UnionTypeAnnotation, opts?: Object): mixed {
    return t.assertUnionTypeAnnotation(...arguments);
  },
  assertUpdateExpression(value: UpdateExpression, opts?: Object): mixed {
    return t.assertUpdateExpression(...arguments);
  },
  assertVariableDeclaration(value: VariableDeclaration, opts?: Object): mixed {
    return t.assertVariableDeclaration(...arguments);
  },
  assertVariableDeclarator(value: VariableDeclarator, opts?: Object): mixed {
    return t.assertVariableDeclarator(...arguments);
  },
  assertVoidTypeAnnotation(value: VoidTypeAnnotation, opts?: Object): mixed {
    return t.assertVoidTypeAnnotation(...arguments);
  },
  assertWhileStatement(value: WhileStatement, opts?: Object): mixed {
    return t.assertWhileStatement(...arguments);
  },
  assertWithStatement(value: WithStatement, opts?: Object): mixed {
    return t.assertWithStatement(...arguments);
  },
  assertYieldExpression(value: YieldExpression, opts?: Object): mixed {
    return t.assertYieldExpression(...arguments);
  },
  asAnyTypeAnnotation(value: any, opts?: Object): AnyTypeAnnotation | void {
    return t.isAnyTypeAnnotation(...arguments) ? (value: any) : undefined;
  },
  asArrayExpression(value: any, opts?: Object): ArrayExpression | void {
    return t.isArrayExpression(...arguments) ? (value: any) : undefined;
  },
  asArrayPattern(value: any, opts?: Object): ArrayPattern | void {
    return t.isArrayPattern(...arguments) ? (value: any) : undefined;
  },
  asArrayTypeAnnotation(value: any, opts?: Object): ArrayTypeAnnotation | void {
    return t.isArrayTypeAnnotation(...arguments) ? (value: any) : undefined;
  },
  asArrowFunctionExpression(value: any, opts?: Object): ArrowFunctionExpression | void {
    return t.isArrowFunctionExpression(...arguments) ? (value: any) : undefined;
  },
  asAssignmentExpression(value: any, opts?: Object): AssignmentExpression | void {
    return t.isAssignmentExpression(...arguments) ? (value: any) : undefined;
  },
  asAssignmentPattern(value: any, opts?: Object): AssignmentPattern | void {
    return t.isAssignmentPattern(...arguments) ? (value: any) : undefined;
  },
  asAwaitExpression(value: any, opts?: Object): AwaitExpression | void {
    return t.isAwaitExpression(...arguments) ? (value: any) : undefined;
  },
  asBinaryExpression(value: any, opts?: Object): BinaryExpression | void {
    return t.isBinaryExpression(...arguments) ? (value: any) : undefined;
  },
  asBindExpression(value: any, opts?: Object): BindExpression | void {
    return t.isBindExpression(...arguments) ? (value: any) : undefined;
  },
  asBlockStatement(value: any, opts?: Object): BlockStatement | void {
    return t.isBlockStatement(...arguments) ? (value: any) : undefined;
  },
  asBooleanLiteral(value: any, opts?: Object): BooleanLiteral | void {
    return t.isBooleanLiteral(...arguments) ? (value: any) : undefined;
  },
  asBooleanLiteralTypeAnnotation(value: any, opts?: Object): BooleanLiteralTypeAnnotation | void {
    return t.isBooleanLiteralTypeAnnotation(...arguments) ? (value: any) : undefined;
  },
  asBooleanTypeAnnotation(value: any, opts?: Object): BooleanTypeAnnotation | void {
    return t.isBooleanTypeAnnotation(...arguments) ? (value: any) : undefined;
  },
  asBreakStatement(value: any, opts?: Object): BreakStatement | void {
    return t.isBreakStatement(...arguments) ? (value: any) : undefined;
  },
  asCallExpression(value: any, opts?: Object): CallExpression | void {
    return t.isCallExpression(...arguments) ? (value: any) : undefined;
  },
  asCatchClause(value: any, opts?: Object): CatchClause | void {
    return t.isCatchClause(...arguments) ? (value: any) : undefined;
  },
  asClassBody(value: any, opts?: Object): ClassBody | void {
    return t.isClassBody(...arguments) ? (value: any) : undefined;
  },
  asClassDeclaration(value: any, opts?: Object): ClassDeclaration | void {
    return t.isClassDeclaration(...arguments) ? (value: any) : undefined;
  },
  asClassExpression(value: any, opts?: Object): ClassExpression | void {
    return t.isClassExpression(...arguments) ? (value: any) : undefined;
  },
  asClassImplements(value: any, opts?: Object): ClassImplements | void {
    return t.isClassImplements(...arguments) ? (value: any) : undefined;
  },
  asClassMethod(value: any, opts?: Object): ClassMethod | void {
    return t.isClassMethod(...arguments) ? (value: any) : undefined;
  },
  asClassProperty(value: any, opts?: Object): ClassProperty | void {
    return t.isClassProperty(...arguments) ? (value: any) : undefined;
  },
  asConditionalExpression(value: any, opts?: Object): ConditionalExpression | void {
    return t.isConditionalExpression(...arguments) ? (value: any) : undefined;
  },
  asContinueStatement(value: any, opts?: Object): ContinueStatement | void {
    return t.isContinueStatement(...arguments) ? (value: any) : undefined;
  },
  asDebuggerStatement(value: any, opts?: Object): DebuggerStatement | void {
    return t.isDebuggerStatement(...arguments) ? (value: any) : undefined;
  },
  asDeclareClass(value: any, opts?: Object): DeclareClass | void {
    return t.isDeclareClass(...arguments) ? (value: any) : undefined;
  },
  asDeclareFunction(value: any, opts?: Object): DeclareFunction | void {
    return t.isDeclareFunction(...arguments) ? (value: any) : undefined;
  },
  asDeclareInterface(value: any, opts?: Object): DeclareInterface | void {
    return t.isDeclareInterface(...arguments) ? (value: any) : undefined;
  },
  asDeclareModule(value: any, opts?: Object): DeclareModule | void {
    return t.isDeclareModule(...arguments) ? (value: any) : undefined;
  },
  asDeclareModuleExports(value: any, opts?: Object): DeclareModuleExports | void {
    return t.isDeclareModuleExports(...arguments) ? (value: any) : undefined;
  },
  asDeclareTypeAlias(value: any, opts?: Object): DeclareTypeAlias | void {
    return t.isDeclareTypeAlias(...arguments) ? (value: any) : undefined;
  },
  asDeclareVariable(value: any, opts?: Object): DeclareVariable | void {
    return t.isDeclareVariable(...arguments) ? (value: any) : undefined;
  },
  asDecorator(value: any, opts?: Object): Decorator | void {
    return t.isDecorator(...arguments) ? (value: any) : undefined;
  },
  asDirective(value: any, opts?: Object): Directive | void {
    return t.isDirective(...arguments) ? (value: any) : undefined;
  },
  asDirectiveLiteral(value: any, opts?: Object): DirectiveLiteral | void {
    return t.isDirectiveLiteral(...arguments) ? (value: any) : undefined;
  },
  asDoExpression(value: any, opts?: Object): DoExpression | void {
    return t.isDoExpression(...arguments) ? (value: any) : undefined;
  },
  asDoWhileStatement(value: any, opts?: Object): DoWhileStatement | void {
    return t.isDoWhileStatement(...arguments) ? (value: any) : undefined;
  },
  asEmptyStatement(value: any, opts?: Object): EmptyStatement | void {
    return t.isEmptyStatement(...arguments) ? (value: any) : undefined;
  },
  asEmptyTypeAnnotation(value: any, opts?: Object): EmptyTypeAnnotation | void {
    return t.isEmptyTypeAnnotation(...arguments) ? (value: any) : undefined;
  },
  asExistentialTypeParam(value: any, opts?: Object): ExistentialTypeParam | void {
    return t.isExistentialTypeParam(...arguments) ? (value: any) : undefined;
  },
  asExportAllDeclaration(value: any, opts?: Object): ExportAllDeclaration | void {
    return t.isExportAllDeclaration(...arguments) ? (value: any) : undefined;
  },
  asExportDefaultDeclaration(value: any, opts?: Object): ExportDefaultDeclaration | void {
    return t.isExportDefaultDeclaration(...arguments) ? (value: any) : undefined;
  },
  asExportDefaultSpecifier(value: any, opts?: Object): ExportDefaultSpecifier | void {
    return t.isExportDefaultSpecifier(...arguments) ? (value: any) : undefined;
  },
  asExportNamedDeclaration(value: any, opts?: Object): ExportNamedDeclaration | void {
    return t.isExportNamedDeclaration(...arguments) ? (value: any) : undefined;
  },
  asExportNamespaceSpecifier(value: any, opts?: Object): ExportNamespaceSpecifier | void {
    return t.isExportNamespaceSpecifier(...arguments) ? (value: any) : undefined;
  },
  asExportSpecifier(value: any, opts?: Object): ExportSpecifier | void {
    return t.isExportSpecifier(...arguments) ? (value: any) : undefined;
  },
  asExpressionStatement(value: any, opts?: Object): ExpressionStatement | void {
    return t.isExpressionStatement(...arguments) ? (value: any) : undefined;
  },
  asFile(value: any, opts?: Object): File | void {
    return t.isFile(...arguments) ? (value: any) : undefined;
  },
  asForAwaitStatement(value: any, opts?: Object): ForAwaitStatement | void {
    return t.isForAwaitStatement(...arguments) ? (value: any) : undefined;
  },
  asForInStatement(value: any, opts?: Object): ForInStatement | void {
    return t.isForInStatement(...arguments) ? (value: any) : undefined;
  },
  asForOfStatement(value: any, opts?: Object): ForOfStatement | void {
    return t.isForOfStatement(...arguments) ? (value: any) : undefined;
  },
  asForStatement(value: any, opts?: Object): ForStatement | void {
    return t.isForStatement(...arguments) ? (value: any) : undefined;
  },
  asFunctionDeclaration(value: any, opts?: Object): FunctionDeclaration | void {
    return t.isFunctionDeclaration(...arguments) ? (value: any) : undefined;
  },
  asFunctionExpression(value: any, opts?: Object): FunctionExpression | void {
    return t.isFunctionExpression(...arguments) ? (value: any) : undefined;
  },
  asFunctionTypeAnnotation(value: any, opts?: Object): FunctionTypeAnnotation | void {
    return t.isFunctionTypeAnnotation(...arguments) ? (value: any) : undefined;
  },
  asFunctionTypeParam(value: any, opts?: Object): FunctionTypeParam | void {
    return t.isFunctionTypeParam(...arguments) ? (value: any) : undefined;
  },
  asGenericTypeAnnotation(value: any, opts?: Object): GenericTypeAnnotation | void {
    return t.isGenericTypeAnnotation(...arguments) ? (value: any) : undefined;
  },
  asIdentifier(value: any, opts?: Object): Identifier | void {
    return t.isIdentifier(...arguments) ? (value: any) : undefined;
  },
  asIfStatement(value: any, opts?: Object): IfStatement | void {
    return t.isIfStatement(...arguments) ? (value: any) : undefined;
  },
  asImport(value: any, opts?: Object): Import | void {
    return t.isImport(...arguments) ? (value: any) : undefined;
  },
  asImportDeclaration(value: any, opts?: Object): ImportDeclaration | void {
    return t.isImportDeclaration(...arguments) ? (value: any) : undefined;
  },
  asImportDefaultSpecifier(value: any, opts?: Object): ImportDefaultSpecifier | void {
    return t.isImportDefaultSpecifier(...arguments) ? (value: any) : undefined;
  },
  asImportNamespaceSpecifier(value: any, opts?: Object): ImportNamespaceSpecifier | void {
    return t.isImportNamespaceSpecifier(...arguments) ? (value: any) : undefined;
  },
  asImportSpecifier(value: any, opts?: Object): ImportSpecifier | void {
    return t.isImportSpecifier(...arguments) ? (value: any) : undefined;
  },
  asInterfaceDeclaration(value: any, opts?: Object): InterfaceDeclaration | void {
    return t.isInterfaceDeclaration(...arguments) ? (value: any) : undefined;
  },
  asInterfaceExtends(value: any, opts?: Object): InterfaceExtends | void {
    return t.isInterfaceExtends(...arguments) ? (value: any) : undefined;
  },
  asIntersectionTypeAnnotation(value: any, opts?: Object): IntersectionTypeAnnotation | void {
    return t.isIntersectionTypeAnnotation(...arguments) ? (value: any) : undefined;
  },
  asJSXAttribute(value: any, opts?: Object): JSXAttribute | void {
    return t.isJSXAttribute(...arguments) ? (value: any) : undefined;
  },
  asJSXClosingElement(value: any, opts?: Object): JSXClosingElement | void {
    return t.isJSXClosingElement(...arguments) ? (value: any) : undefined;
  },
  asJSXElement(value: any, opts?: Object): JSXElement | void {
    return t.isJSXElement(...arguments) ? (value: any) : undefined;
  },
  asJSXEmptyExpression(value: any, opts?: Object): JSXEmptyExpression | void {
    return t.isJSXEmptyExpression(...arguments) ? (value: any) : undefined;
  },
  asJSXExpressionContainer(value: any, opts?: Object): JSXExpressionContainer | void {
    return t.isJSXExpressionContainer(...arguments) ? (value: any) : undefined;
  },
  asJSXIdentifier(value: any, opts?: Object): JSXIdentifier | void {
    return t.isJSXIdentifier(...arguments) ? (value: any) : undefined;
  },
  asJSXMemberExpression(value: any, opts?: Object): JSXMemberExpression | void {
    return t.isJSXMemberExpression(...arguments) ? (value: any) : undefined;
  },
  asJSXNamespacedName(value: any, opts?: Object): JSXNamespacedName | void {
    return t.isJSXNamespacedName(...arguments) ? (value: any) : undefined;
  },
  asJSXOpeningElement(value: any, opts?: Object): JSXOpeningElement | void {
    return t.isJSXOpeningElement(...arguments) ? (value: any) : undefined;
  },
  asJSXSpreadAttribute(value: any, opts?: Object): JSXSpreadAttribute | void {
    return t.isJSXSpreadAttribute(...arguments) ? (value: any) : undefined;
  },
  asJSXSpreadChild(value: any, opts?: Object): JSXSpreadChild | void {
    return t.isJSXSpreadChild(...arguments) ? (value: any) : undefined;
  },
  asJSXText(value: any, opts?: Object): JSXText | void {
    return t.isJSXText(...arguments) ? (value: any) : undefined;
  },
  asLabeledStatement(value: any, opts?: Object): LabeledStatement | void {
    return t.isLabeledStatement(...arguments) ? (value: any) : undefined;
  },
  asLogicalExpression(value: any, opts?: Object): LogicalExpression | void {
    return t.isLogicalExpression(...arguments) ? (value: any) : undefined;
  },
  asMemberExpression(value: any, opts?: Object): MemberExpression | void {
    return t.isMemberExpression(...arguments) ? (value: any) : undefined;
  },
  asMetaProperty(value: any, opts?: Object): MetaProperty | void {
    return t.isMetaProperty(...arguments) ? (value: any) : undefined;
  },
  asMixedTypeAnnotation(value: any, opts?: Object): MixedTypeAnnotation | void {
    return t.isMixedTypeAnnotation(...arguments) ? (value: any) : undefined;
  },
  asNewExpression(value: any, opts?: Object): NewExpression | void {
    return t.isNewExpression(...arguments) ? (value: any) : undefined;
  },
  asNoop(value: any, opts?: Object): Noop | void {
    return t.isNoop(...arguments) ? (value: any) : undefined;
  },
  asNullLiteral(value: any, opts?: Object): NullLiteral | void {
    return t.isNullLiteral(...arguments) ? (value: any) : undefined;
  },
  asNullLiteralTypeAnnotation(value: any, opts?: Object): NullLiteralTypeAnnotation | void {
    return t.isNullLiteralTypeAnnotation(...arguments) ? (value: any) : undefined;
  },
  asNullableTypeAnnotation(value: any, opts?: Object): NullableTypeAnnotation | void {
    return t.isNullableTypeAnnotation(...arguments) ? (value: any) : undefined;
  },
  asNumberTypeAnnotation(value: any, opts?: Object): NumberTypeAnnotation | void {
    return t.isNumberTypeAnnotation(...arguments) ? (value: any) : undefined;
  },
  asNumericLiteral(value: any, opts?: Object): NumericLiteral | void {
    return t.isNumericLiteral(...arguments) ? (value: any) : undefined;
  },
  asNumericLiteralTypeAnnotation(value: any, opts?: Object): NumericLiteralTypeAnnotation | void {
    return t.isNumericLiteralTypeAnnotation(...arguments) ? (value: any) : undefined;
  },
  asObjectExpression(value: any, opts?: Object): ObjectExpression | void {
    return t.isObjectExpression(...arguments) ? (value: any) : undefined;
  },
  asObjectMethod(value: any, opts?: Object): ObjectMethod | void {
    return t.isObjectMethod(...arguments) ? (value: any) : undefined;
  },
  asObjectPattern(value: any, opts?: Object): ObjectPattern | void {
    return t.isObjectPattern(...arguments) ? (value: any) : undefined;
  },
  asObjectProperty(value: any, opts?: Object): ObjectProperty | void {
    return t.isObjectProperty(...arguments) ? (value: any) : undefined;
  },
  asObjectTypeAnnotation(value: any, opts?: Object): ObjectTypeAnnotation | void {
    return t.isObjectTypeAnnotation(...arguments) ? (value: any) : undefined;
  },
  asObjectTypeCallProperty(value: any, opts?: Object): ObjectTypeCallProperty | void {
    return t.isObjectTypeCallProperty(...arguments) ? (value: any) : undefined;
  },
  asObjectTypeIndexer(value: any, opts?: Object): ObjectTypeIndexer | void {
    return t.isObjectTypeIndexer(...arguments) ? (value: any) : undefined;
  },
  asObjectTypeProperty(value: any, opts?: Object): ObjectTypeProperty | void {
    return t.isObjectTypeProperty(...arguments) ? (value: any) : undefined;
  },
  asParenthesizedExpression(value: any, opts?: Object): ParenthesizedExpression | void {
    return t.isParenthesizedExpression(...arguments) ? (value: any) : undefined;
  },
  asProgram(value: any, opts?: Object): Program | void {
    return t.isProgram(...arguments) ? (value: any) : undefined;
  },
  asQualifiedTypeIdentifier(value: any, opts?: Object): QualifiedTypeIdentifier | void {
    return t.isQualifiedTypeIdentifier(...arguments) ? (value: any) : undefined;
  },
  asRegExpLiteral(value: any, opts?: Object): RegExpLiteral | void {
    return t.isRegExpLiteral(...arguments) ? (value: any) : undefined;
  },
  asRestElement(value: any, opts?: Object): RestElement | void {
    return t.isRestElement(...arguments) ? (value: any) : undefined;
  },
  asRestProperty(value: any, opts?: Object): RestProperty | void {
    return t.isRestProperty(...arguments) ? (value: any) : undefined;
  },
  asReturnStatement(value: any, opts?: Object): ReturnStatement | void {
    return t.isReturnStatement(...arguments) ? (value: any) : undefined;
  },
  asSequenceExpression(value: any, opts?: Object): SequenceExpression | void {
    return t.isSequenceExpression(...arguments) ? (value: any) : undefined;
  },
  asSpreadElement(value: any, opts?: Object): SpreadElement | void {
    return t.isSpreadElement(...arguments) ? (value: any) : undefined;
  },
  asSpreadProperty(value: any, opts?: Object): SpreadProperty | void {
    return t.isSpreadProperty(...arguments) ? (value: any) : undefined;
  },
  asStringLiteral(value: any, opts?: Object): StringLiteral | void {
    return t.isStringLiteral(...arguments) ? (value: any) : undefined;
  },
  asStringLiteralTypeAnnotation(value: any, opts?: Object): StringLiteralTypeAnnotation | void {
    return t.isStringLiteralTypeAnnotation(...arguments) ? (value: any) : undefined;
  },
  asStringTypeAnnotation(value: any, opts?: Object): StringTypeAnnotation | void {
    return t.isStringTypeAnnotation(...arguments) ? (value: any) : undefined;
  },
  asSuper(value: any, opts?: Object): Super | void {
    return t.isSuper(...arguments) ? (value: any) : undefined;
  },
  asSwitchCase(value: any, opts?: Object): SwitchCase | void {
    return t.isSwitchCase(...arguments) ? (value: any) : undefined;
  },
  asSwitchStatement(value: any, opts?: Object): SwitchStatement | void {
    return t.isSwitchStatement(...arguments) ? (value: any) : undefined;
  },
  asTaggedTemplateExpression(value: any, opts?: Object): TaggedTemplateExpression | void {
    return t.isTaggedTemplateExpression(...arguments) ? (value: any) : undefined;
  },
  asTemplateElement(value: any, opts?: Object): TemplateElement | void {
    return t.isTemplateElement(...arguments) ? (value: any) : undefined;
  },
  asTemplateLiteral(value: any, opts?: Object): TemplateLiteral | void {
    return t.isTemplateLiteral(...arguments) ? (value: any) : undefined;
  },
  asThisExpression(value: any, opts?: Object): ThisExpression | void {
    return t.isThisExpression(...arguments) ? (value: any) : undefined;
  },
  asThisTypeAnnotation(value: any, opts?: Object): ThisTypeAnnotation | void {
    return t.isThisTypeAnnotation(...arguments) ? (value: any) : undefined;
  },
  asThrowStatement(value: any, opts?: Object): ThrowStatement | void {
    return t.isThrowStatement(...arguments) ? (value: any) : undefined;
  },
  asTryStatement(value: any, opts?: Object): TryStatement | void {
    return t.isTryStatement(...arguments) ? (value: any) : undefined;
  },
  asTupleTypeAnnotation(value: any, opts?: Object): TupleTypeAnnotation | void {
    return t.isTupleTypeAnnotation(...arguments) ? (value: any) : undefined;
  },
  asTypeAlias(value: any, opts?: Object): TypeAlias | void {
    return t.isTypeAlias(...arguments) ? (value: any) : undefined;
  },
  asTypeAnnotation(value: any, opts?: Object): TypeAnnotation | void {
    return t.isTypeAnnotation(...arguments) ? (value: any) : undefined;
  },
  asTypeCastExpression(value: any, opts?: Object): TypeCastExpression | void {
    return t.isTypeCastExpression(...arguments) ? (value: any) : undefined;
  },
  asTypeParameter(value: any, opts?: Object): TypeParameter | void {
    return t.isTypeParameter(...arguments) ? (value: any) : undefined;
  },
  asTypeParameterDeclaration(value: any, opts?: Object): TypeParameterDeclaration | void {
    return t.isTypeParameterDeclaration(...arguments) ? (value: any) : undefined;
  },
  asTypeParameterInstantiation(value: any, opts?: Object): TypeParameterInstantiation | void {
    return t.isTypeParameterInstantiation(...arguments) ? (value: any) : undefined;
  },
  asTypeofTypeAnnotation(value: any, opts?: Object): TypeofTypeAnnotation | void {
    return t.isTypeofTypeAnnotation(...arguments) ? (value: any) : undefined;
  },
  asUnaryExpression(value: any, opts?: Object): UnaryExpression | void {
    return t.isUnaryExpression(...arguments) ? (value: any) : undefined;
  },
  asUnionTypeAnnotation(value: any, opts?: Object): UnionTypeAnnotation | void {
    return t.isUnionTypeAnnotation(...arguments) ? (value: any) : undefined;
  },
  asUpdateExpression(value: any, opts?: Object): UpdateExpression | void {
    return t.isUpdateExpression(...arguments) ? (value: any) : undefined;
  },
  asVariableDeclaration(value: any, opts?: Object): VariableDeclaration | void {
    return t.isVariableDeclaration(...arguments) ? (value: any) : undefined;
  },
  asVariableDeclarator(value: any, opts?: Object): VariableDeclarator | void {
    return t.isVariableDeclarator(...arguments) ? (value: any) : undefined;
  },
  asVoidTypeAnnotation(value: any, opts?: Object): VoidTypeAnnotation | void {
    return t.isVoidTypeAnnotation(...arguments) ? (value: any) : undefined;
  },
  asWhileStatement(value: any, opts?: Object): WhileStatement | void {
    return t.isWhileStatement(...arguments) ? (value: any) : undefined;
  },
  asWithStatement(value: any, opts?: Object): WithStatement | void {
    return t.isWithStatement(...arguments) ? (value: any) : undefined;
  },
  asYieldExpression(value: any, opts?: Object): YieldExpression | void {
    return t.isYieldExpression(...arguments) ? (value: any) : undefined;
  },
};

export default BabelTypes;
